// 1. Почему React использует свой SyntheticEvent, и какие преимущества это даёт?
// Кросс-браузерность, Пуллинг и оптимизация памяти, Контроль и совместимость с системой обновлений React

// 2. Как работает алгоритм reconciliation (Fiber)?
// [доклад] Подробно о React Reconciliation, или Как React добился 60 fps
// если тип ноды (div, MyComponent) совпадает → сравни только props и детей,
// если есть key (у списков) → можно быстро найти соответствие между старым и новым,
// если нет key, но порядок не менялся — сравни по порядку (i-й с i-м),

// 3. Чем отличается memo от useMemo и когда их не стоит применять?

// 4. Почему нельзя условно вызывать хуки (Hooks) в React?

// 5. В каких случаях React.StrictMode дважды вызывает эффект useEffect в dev-режиме?

// 6. Что такое Error Boundary, и почему его нельзя реализовать с помощью хуков?

// 7. В чём реальная разница между компонентами и элементами в React?

// 8. Как оптимально обрабатывать анимации в React-приложениях?

// 9. Почему использование ключей при рендеринге списков влияет на производительность?

// 10. Что за «concurrent rendering» и как он может сломать приложение, если использовать неправильно?


// 10 задротских вопросов про JavaScript, после которых ты усомнишься, что вообще знаешь JS. Часть 2. 

// Как и почему NaN !== NaN, но при этом Object.is(NaN, NaN) === true?

// В каких случаях можно увидеть, что (0.1 + 0.2) !== 0.3?

// Как реализована очередь микрозадач в event loop?

// Почему typeof null возвращает "object"?

// Как работает hoisting для объявлений через var, let и const?

// Что такое "Temporal Dead Zone"?

// В чём разница между shallow и deep copy в JS?

// Чем отличаются Map и WeakMap, и зачем нужны последние?

// Почему массивы в JS на самом деле не массивы?

// Как работает замыкание и какие у него «подводные камни»?



